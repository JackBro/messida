diff --git a/src/emu/debug/debugcpu.c b/src/emu/debug/debugcpu.c
index 4803052..af4bcaa 100644
--- a/src/emu/debug/debugcpu.c
+++ b/src/emu/debug/debugcpu.c
@@ -22,6 +22,15 @@
 #include "coreutil.h"
 #include <ctype.h>
 
+#if defined (C_IDA_DEBUG)
+#include "mess_debmod.h"
+
+extern running_machine *g_running_machine;
+extern codemap_t g_codemap;
+extern eventlist_t g_events;
+
+#define sprintf(str, format, x) qsnprintf(str, sizeof(str), format, (x))
+#endif
 
 /***************************************************************************
     CONSTANTS
@@ -1702,6 +1711,9 @@ device_debug::~device_debug()
 
 void device_debug::start_hook(const attotime &endtime)
 {
+#if defined (C_IDA_DEBUG)
+	g_running_machine = &m_device.machine();
+#endif
 	debugcpu_private *global = m_device.machine().debugcpu_data;
 
 	assert((m_device.machine().debug_flags & DEBUG_FLAG_ENABLED) != 0);
@@ -1752,8 +1764,10 @@ void device_debug::start_hook(const attotime &endtime)
 			}
 		}
 		// check for debug keypresses
+#if !defined (C_IDA_DEBUG)
 		if (ui_input_pressed(m_device.machine(), IPT_UI_DEBUG_BREAK))
 			global->visiblecpu->debug()->halt_on_next_instruction("User-initiated break\n");
+#endif
 	}
 
 	// recompute the debugging mode
@@ -1822,6 +1836,11 @@ void device_debug::exception_hook(int exception)
 
 void device_debug::instruction_hook(offs_t curpc)
 {
+#if defined (C_IDA_DEBUG)
+	offs_t _pc = m_device.machine().firstcpu->pc();
+	if (_pc >= 0 && _pc < MAX_ROM_SIZE)
+		g_codemap[_pc] = std::pair<ea_t, bool>(m_pc_history[(m_pc_history_index-1) % HISTORY_SIZE], true);
+#endif
 	running_machine &machine = m_device.machine();
 	debugcpu_private *global = machine.debugcpu_data;
 
@@ -1899,6 +1918,36 @@ void device_debug::instruction_hook(offs_t curpc)
 	// if we are supposed to halt, do it now
 	if (global->execution_state == EXECUTION_STATE_STOPPED)
 	{
+#if defined (C_IDA_DEBUG)
+		debug_event_t ev;
+		ev.pid = 1;
+		ev.tid = 1;
+		ev.ea = curpc;
+		ev.handled = true;
+
+		bool send;
+		if (m_flags & DEBUG_FLAG_STEPPING_ANY)
+		{
+			ev.eid = STEP;
+			send = true;
+		}
+		else if ((m_flags & DEBUG_FLAG_STOP_PC) && (m_flags & DEBUG_FLAG_LIVE_BP))
+		{
+			send = false;
+		}
+		else if (m_flags & DEBUG_FLAG_STOP_INTERRUPT)
+		{
+			send = false;
+		}
+		else
+		{
+			ev.eid = PROCESS_SUSPEND;
+			send = true;
+		}
+
+		if (send)
+			g_events.enqueue(ev, IN_BACK);
+#endif
 		bool firststop = true;
 
 		// load comments if we haven't yet
@@ -2910,7 +2959,22 @@ void device_debug::breakpoint_check(offs_t pc)
 
 			// print a notification, unless the action made us go again
 			if (global->execution_state == EXECUTION_STATE_STOPPED)
+			{
 				debug_console_printf(m_device.machine(), "Stopped at breakpoint %X\n", bp->m_index);
+#if defined (C_IDA_DEBUG)
+				debug_event_t ev;
+				ev.eid = BREAKPOINT;
+				ev.pid = 1;
+				ev.tid = 1;
+				ev.ea = pc;
+				ev.handled = true;
+
+				ev.bpt.hea = BADADDR;
+				ev.bpt.kea = BADADDR;
+
+				g_events.enqueue(ev, IN_BACK);
+#endif
+			}
 			break;
 		}
 
@@ -2933,6 +2997,19 @@ void device_debug::breakpoint_check(offs_t pc)
 			if (global->execution_state == EXECUTION_STATE_STOPPED)
 			{
 				debug_console_printf(m_device.machine(), "Stopped at registerpoint %X\n", rp->m_index);
+#if defined (C_IDA_DEBUG)
+				debug_event_t ev;
+				ev.eid = BREAKPOINT;
+				ev.pid = 1;
+				ev.tid = 1;
+				ev.ea = pc;
+				ev.handled = true;
+
+				ev.bpt.hea = BADADDR;
+				ev.bpt.kea = BADADDR;
+
+				g_events.enqueue(ev, IN_BACK);
+#endif
 			}
 			break;
 		}
@@ -3059,6 +3136,20 @@ void device_debug::watchpoint_check(address_space &space, int type, offs_t addre
 					strprintf(buffer,"Stopped at watchpoint %X reading %s from %08X (PC=%X)", wp->m_index, sizes[size], space.byte_to_address(address), pc);
 				debug_console_printf(space.machine(), "%s\n", buffer.c_str());
 				space.device().debug()->compute_debug_flags();
+
+#if defined (C_IDA_DEBUG)
+				debug_event_t ev;
+				ev.eid = BREAKPOINT;
+				ev.pid = 1;
+				ev.tid = 1;
+				ev.ea = pc;
+				ev.handled = true;
+
+				ev.bpt.hea = address;
+				ev.bpt.kea = address;
+
+				g_events.enqueue(ev, IN_BACK);
+#endif
 			}
 			break;
 		}
diff --git a/src/emu/machine.c b/src/emu/machine.c
index 3f0eb5a..dd2a387 100644
--- a/src/emu/machine.c
+++ b/src/emu/machine.c
@@ -91,6 +91,12 @@
 void js_set_main_loop(running_machine * machine);
 #endif
 
+#if defined (C_IDA_DEBUG)
+#include "mess_debmod.h"
+
+extern eventlist_t g_events;
+#endif
+
 
 
 //**************************************************************************
@@ -970,6 +976,21 @@ cancel:
 
 void running_machine::soft_reset(void *ptr, INT32 param)
 {
+#if defined (C_IDA_DEBUG)
+	debug_event_t ev;
+	ev.eid = PROCESS_START;
+	ev.pid = 1;
+	ev.tid = 1;
+	ev.ea = BADADDR;
+	ev.handled = true;
+
+	ev.modinfo.name[0] = '\0';
+	ev.modinfo.base = 0;
+	ev.modinfo.size = 0;
+	ev.modinfo.rebase_to = BADADDR;
+
+	g_events.enqueue(ev, IN_BACK);
+#endif
 	logerror("Soft reset\n");
 
 	// temporarily in the reset phase
diff --git a/src/osd/modules/debugger/debugwin.c b/src/osd/modules/debugger/debugwin.c
index 5f07e0d..dfa3528 100644
--- a/src/osd/modules/debugger/debugwin.c
+++ b/src/osd/modules/debugger/debugwin.c
@@ -113,7 +113,9 @@ void debugger_windows::wait_for_debugger(device_t &device, bool firststop)
 	// when we are first stopped, adjust focus to us
 	if (firststop && (m_main_console != NULL))
 	{
+#if !defined (C_IDA_DEBUG)
 		m_main_console->set_foreground();
+#endif
 		if (winwindow_has_focus())
 			m_main_console->set_default_focus();
 	}
